[{"text":"{\n    \"tiddlers\": {\n        \"$:/core/modules/parsers/wikiparser/attributes/filtered.js\": {\n            \"title\": \"$:/core/modules/parsers/wikiparser/attributes/filtered.js\",\n            \"created\": \"20171224215126050\",\n            \"description\": \"Tag attribute rule for filtered values, eg. {{{[all[shadows]]}}}.\",\n            \"modified\": \"20171224215155435\",\n            \"module-type\": \"attributerule\",\n            \"revision\": \"0\",\n            \"tags\": \"\",\n            \"type\": \"application/javascript\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/wikiparser/attributes/filtered.js\\ntype: application/javascript\\nmodule-type: attributerule\\n\\nTag attribute parser rule for filtered values, eg. {{{[all[shadows]]}}}.\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.filtered = function(source,pos,node) {\\n\\t// Is it a filtered value?\\n\\tvar reFilteredValue = /\\\\{\\\\{\\\\{(.+?)\\\\}\\\\}\\\\}/g;\\n\\tvar value = $tw.utils.parseTokenRegExp(source,pos,reFilteredValue);\\n\\tif (!value) return null;\\n\\tnode.type = \\\"filtered\\\";\\n\\tnode.filter = value.match[1];\\n\\tnode.end = value.end;\\n\\treturn node;\\n};\\n\\n})();\"\n        },\n        \"$:/core/modules/parsers/wikiparser/attributes/indirect.js\": {\n            \"title\": \"$:/core/modules/parsers/wikiparser/attributes/indirect.js\",\n            \"created\": \"20171224214929513\",\n            \"description\": \"Tag attribute rule for transcluded values, eg. {{Layout!!height}}.\",\n            \"modified\": \"20171224215110965\",\n            \"module-type\": \"attributerule\",\n            \"revision\": \"0\",\n            \"tags\": \"\",\n            \"type\": \"application/javascript\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/wikiparser/attributes/indirect.js\\ntype: application/javascript\\nmodule-type: attributerule\\n\\nTag attribute parser rule for transcluded values, eg. {{Layout!!height}}.\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.indirect = function(source,pos,node) {\\n\\t// Is it an indirect (transcluded) value?\\n\\tvar reIndirectValue = /\\\\{\\\\{([^\\\\{\\\\}]+)\\\\}\\\\}/g;\\n\\tvar value = $tw.utils.parseTokenRegExp(source,pos,reIndirectValue);\\n\\tif (!value) return null;\\n\\tnode.type = \\\"indirect\\\";\\n\\tnode.textReference = value.match[1];\\n\\tnode.end = value.end;\\n\\treturn node;\\n};\\n\\n})();\"\n        },\n        \"$:/core/modules/parsers/wikiparser/attributes/macro.js\": {\n            \"title\": \"$:/core/modules/parsers/wikiparser/attributes/macro.js\",\n            \"created\": \"20171224215158051\",\n            \"description\": \"Tag attribute rule for macros and variables, eg. <<currentTiddler>>.\",\n            \"modified\": \"20171224215427368\",\n            \"module-type\": \"attributerule\",\n            \"revision\": \"0\",\n            \"tags\": \"\",\n            \"type\": \"application/javascript\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/wikiparser/attributes/macro.js\\ntype: application/javascript\\nmodule-type: attributerule\\n\\nTag attribute parser rule for macros and variables, eg. <<currentTiddler>>.\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.macro = function(source,pos,node) {\\n\\t// Is it a macro invocation?\\n\\tvar macroInvocation = $tw.utils.parseMacroInvocation(source,pos);\\n\\tif (!macroInvocation) return null;\\n\\tnode.type = \\\"macro\\\";\\n\\tnode.value = macroInvocation;\\n\\tnode.end = macroInvocation.end;\\n\\treturn node;\\n};\\n\\n})();\"\n        },\n        \"$:/core/modules/widgets/attributes/filtered.js\": {\n            \"title\": \"$:/core/modules/widgets/attributes/filtered.js\",\n            \"created\": \"20171225042329213\",\n            \"description\": \"An attribute value acquired via text reference.\",\n            \"modified\": \"20171225042338300\",\n            \"module-type\": \"attributevalue\",\n            \"revision\": \"0\",\n            \"tags\": \"\",\n            \"type\": \"application/javascript\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/attributes/filtered.js\\ntype: application/javascript\\nmodule-type: attributevalue\\n\\nAn attribute value acquired via filter expression.\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar FilteredAttribute = function(widget,node) {\\n\\tthis.widget = widget;\\n\\tthis.filter = node.filter;\\n\\tthis.compiledFilter = this.widget.wiki.compileFilter(this.filter);\\n\\tthis.value = this.compute();\\n};\\n\\n/*\\nInherit from the base ??? class\\n*/\\n//FormulaAttribute.prototype = new AttributeGizmo();\\n\\nFilteredAttribute.prototype.compute = function() {\\n\\tthis.results = this.compiledFilter.call(this.widget.wiki,undefined,this.widget);\\n\\t// TODO why only one result?  Can we return a list??\\n\\treturn this.results[0] || \\\"\\\";\\n};\\n\\nFilteredAttribute.prototype.refresh = function(changedTiddlers) {\\n\\t// TODO can filters be selectively refreshed in the future?\\n\\tthis.value = this.compute();\\n\\treturn this.value;\\n};\\n\\n\\nexports.filtered = FilteredAttribute;\\n\\n})();\\n\\t\"\n        },\n        \"$:/core/modules/widgets/attributes/indirect.js\": {\n            \"title\": \"$:/core/modules/widgets/attributes/indirect.js\",\n            \"created\": \"20171225042213912\",\n            \"description\": \"An attribute value acquired via text reference.\",\n            \"modified\": \"20171225042325491\",\n            \"module-type\": \"attributevalue\",\n            \"revision\": \"0\",\n            \"tags\": \"\",\n            \"type\": \"application/javascript\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/attributes/indirect.js\\ntype: application/javascript\\nmodule-type: attributevalue\\n\\nAn attribute value acquired via filter expression.\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar IndirectAttribute = function(widget,node) {\\n\\tthis.widget = widget;\\n\\tthis.textReference = $tw.utils.parseTextReference(node.textReference);\\n\\tif (!this.textReference.title) this.currentTiddler = this.widget.getVariable(\\\"currentTiddler\\\");\\n\\tthis.value = this.compute();\\n};\\n\\n/*\\nInherit from the base ??? class\\n*/\\n//FormulaAttribute.prototype = new AttributeGizmo();\\n\\nIndirectAttribute.prototype.compute = function() {\\n\\tvar tr = this.textReference,\\n\\t\\ttitle = tr.title || this.currentTiddler,\\n\\t\\twiki = this.widget.wiki;\\n\\tif(tr.field) {\\n\\t\\tvar tiddler = wiki.getTiddler(title);\\n\\t\\tif(tr.field === \\\"title\\\") { // Special case so we can return the title of a non-existent tiddler\\n\\t\\t\\treturn title;\\n\\t\\t} else if(tiddler && $tw.utils.hop(tiddler.fields,tr.field)) {\\n\\t\\t\\treturn tiddler.getFieldString(tr.field);\\n\\t\\t} else {\\n\\t\\t\\treturn \\\"\\\";\\n\\t\\t}\\n\\t} else if(tr.index) {\\n\\t\\treturn wiki.extractTiddlerDataItem(title,tr.index,\\\"\\\");\\n\\t} else {\\n\\t\\treturn wiki.getTiddlerText(title,\\\"\\\");\\n\\t}\\n};\\n\\nIndirectAttribute.prototype.refresh = function(changedTiddlers) {\\n\\tif (this.textReference.title) {\\n\\t\\t// Recompute if the title tiddler changed.\\n\\t\\tif (changedTiddlers[this.textReference.title])\\n\\t\\t\\tthis.value = this.compute();\\n\\t}\\n\\telse {\\n\\t\\t// Did currentTiddler change?\\n\\t\\tvar newTiddler = this.widget.getVariable(\\\"currentTiddler\\\");\\n\\t\\tif (newTiddler != this.currentTiddler) {\\n\\t\\t\\tthis.currentTiddler = newTiddler;\\n\\t\\t\\tthis.value = this.compute();\\n\\t\\t}\\n\\t\\telse if (changedTiddlers[this.currentTiddler]) {\\n\\t\\t\\t// Recompute if the tiddler changed.\\n\\t\\t\\tthis.value = this.compute();\\n\\t\\t}\\n\\t}\\n\\t// Return the latest value.\\n\\treturn this.value;\\n};\\n\\n\\nexports.indirect = IndirectAttribute;\\n\\n})();\\n\\t\"\n        },\n        \"$:/core/modules/widgets/attributes/macro.js\": {\n            \"title\": \"$:/core/modules/widgets/attributes/macro.js\",\n            \"created\": \"20171225042340029\",\n            \"description\": \"An attribute value acquired via text reference.\",\n            \"modified\": \"20171225042346461\",\n            \"module-type\": \"attributevalue\",\n            \"revision\": \"0\",\n            \"tags\": \"\",\n            \"type\": \"application/javascript\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/attributes/macro.js\\ntype: application/javascript\\nmodule-type: attributevalue\\n\\nAn attribute value acquired via macro expansion.\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar MacroAttribute = function(widget,node) {\\n\\tthis.widget = widget;\\n\\tthis.macro = node.value;\\n\\tthis.value = this.compute();\\n};\\n\\n/*\\nInherit from the base ??? class\\n*/\\n//FormulaAttribute.prototype = new AttributeGizmo();\\n\\nMacroAttribute.prototype.compute = function() {\\n\\tvar value = this.widget.getVariable(this.macro.name,{params: this.macro.params});\\n\\tif (value == null) value = \\\"\\\";\\n\\treturn value;\\n};\\n\\nMacroAttribute.prototype.refresh = function(changedTiddlers) {\\n\\tthis.value = this.compute();\\n\\treturn this.value;\\n};\\n\\n\\nexports.macro = MacroAttribute;\\n\\n})();\\n\\t\"\n        },\n        \"$:/plugins/ebalster/attribute-modules/patchSource/core/modules/utils/parseutils.js\": {\n            \"title\": \"$:/plugins/ebalster/attribute-modules/patchSource/core/modules/utils/parseutils.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/utils/parseutils.js\\ntype: application/javascript\\nmodule-type: utils\\n\\nUtility functions concerned with parsing text into tokens.\\n\\nMost functions have the following pattern:\\n\\n* The parameters are:\\n** `source`: the source string being parsed\\n** `pos`: the current parse position within the string\\n** Any further parameters are used to identify the token that is being parsed\\n* The return value is:\\n** null if the token was not found at the specified position\\n** an object representing the token with the following standard fields:\\n*** `type`: string indicating the type of the token\\n*** `start`: start position of the token in the source string\\n*** `end`: end position of the token in the source string\\n*** Any further fields required to describe the token\\n\\nThe exception is `skipWhiteSpace`, which just returns the position after the whitespace.\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*\\nLook for a whitespace token. Returns null if not found, otherwise returns {type: \\\"whitespace\\\", start:, end:,}\\n*/\\nexports.parseWhiteSpace = function(source,pos) {\\n\\tvar p = pos,c;\\n\\twhile(true) {\\n\\t\\tc = source.charAt(p);\\n\\t\\tif((c === \\\" \\\") || (c === \\\"\\\\f\\\") || (c === \\\"\\\\n\\\") || (c === \\\"\\\\r\\\") || (c === \\\"\\\\t\\\") || (c === \\\"\\\\v\\\") || (c === \\\"\\\\u00a0\\\")) { // Ignores some obscure unicode spaces\\n\\t\\t\\tp++;\\n\\t\\t} else {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tif(p === pos) {\\n\\t\\treturn null;\\n\\t} else {\\n\\t\\treturn {\\n\\t\\t\\ttype: \\\"whitespace\\\",\\n\\t\\t\\tstart: pos,\\n\\t\\t\\tend: p\\n\\t\\t}\\n\\t}\\n};\\n\\n/*\\nConvenience wrapper for parseWhiteSpace. Returns the position after the whitespace\\n*/\\nexports.skipWhiteSpace = function(source,pos) {\\n\\tvar c;\\n\\twhile(true) {\\n\\t\\tc = source.charAt(pos);\\n\\t\\tif((c === \\\" \\\") || (c === \\\"\\\\f\\\") || (c === \\\"\\\\n\\\") || (c === \\\"\\\\r\\\") || (c === \\\"\\\\t\\\") || (c === \\\"\\\\v\\\") || (c === \\\"\\\\u00a0\\\")) { // Ignores some obscure unicode spaces\\n\\t\\t\\tpos++;\\n\\t\\t} else {\\n\\t\\t\\treturn pos;\\n\\t\\t}\\n\\t}\\n};\\n\\n/*\\nLook for a given string token. Returns null if not found, otherwise returns {type: \\\"token\\\", value:, start:, end:,}\\n*/\\nexports.parseTokenString = function(source,pos,token) {\\n\\tvar match = source.indexOf(token,pos) === pos;\\n\\tif(match) {\\n\\t\\treturn {\\n\\t\\t\\ttype: \\\"token\\\",\\n\\t\\t\\tvalue: token,\\n\\t\\t\\tstart: pos,\\n\\t\\t\\tend: pos + token.length\\n\\t\\t};\\n\\t}\\n\\treturn null;\\n};\\n\\n/*\\nLook for a token matching a regex. Returns null if not found, otherwise returns {type: \\\"regexp\\\", match:, start:, end:,}\\n*/\\nexports.parseTokenRegExp = function(source,pos,reToken) {\\n\\tvar node = {\\n\\t\\ttype: \\\"regexp\\\",\\n\\t\\tstart: pos\\n\\t};\\n\\treToken.lastIndex = pos;\\n\\tnode.match = reToken.exec(source);\\n\\tif(node.match && node.match.index === pos) {\\n\\t\\tnode.end = pos + node.match[0].length;\\n\\t\\treturn node;\\n\\t} else {\\n\\t\\treturn null;\\n\\t}\\n};\\n\\n/*\\nLook for a string literal. Returns null if not found, otherwise returns {type: \\\"string\\\", value:, start:, end:,}\\n*/\\nexports.parseStringLiteral = function(source,pos) {\\n\\tvar node = {\\n\\t\\ttype: \\\"string\\\",\\n\\t\\tstart: pos\\n\\t};\\n\\tvar reString = /(?:\\\"\\\"\\\"([\\\\s\\\\S]*?)\\\"\\\"\\\"|\\\"([^\\\"]*)\\\")|(?:'([^']*)')/g;\\n\\treString.lastIndex = pos;\\n\\tvar match = reString.exec(source);\\n\\tif(match && match.index === pos) {\\n\\t\\tnode.value = match[1] !== undefined ? match[1] :(\\n\\t\\t\\tmatch[2] !== undefined ? match[2] : match[3] \\n\\t\\t\\t\\t\\t);\\n\\t\\tnode.end = pos + match[0].length;\\n\\t\\treturn node;\\n\\t} else {\\n\\t\\treturn null;\\n\\t}\\n};\\n\\n/*\\nLook for a macro invocation parameter. Returns null if not found, or {type: \\\"macro-parameter\\\", name:, value:, start:, end:}\\n*/\\nexports.parseMacroParameter = function(source,pos) {\\n\\tvar node = {\\n\\t\\ttype: \\\"macro-parameter\\\",\\n\\t\\tstart: pos\\n\\t};\\n\\t// Define our regexp\\n\\tvar reMacroParameter = /(?:([A-Za-z0-9\\\\-_]+)\\\\s*:)?(?:\\\\s*(?:\\\"\\\"\\\"([\\\\s\\\\S]*?)\\\"\\\"\\\"|\\\"([^\\\"]*)\\\"|'([^']*)'|\\\\[\\\\[([^\\\\]]*)\\\\]\\\\]|([^\\\\s>\\\"'=]+)))/g;\\n\\t// Skip whitespace\\n\\tpos = $tw.utils.skipWhiteSpace(source,pos);\\n\\t// Look for the parameter\\n\\tvar token = $tw.utils.parseTokenRegExp(source,pos,reMacroParameter);\\n\\tif(!token) {\\n\\t\\treturn null;\\n\\t}\\n\\tpos = token.end;\\n\\t// Get the parameter details\\n\\tnode.value = token.match[2] !== undefined ? token.match[2] : (\\n\\t\\t\\t\\t\\ttoken.match[3] !== undefined ? token.match[3] : (\\n\\t\\t\\t\\t\\t\\ttoken.match[4] !== undefined ? token.match[4] : (\\n\\t\\t\\t\\t\\t\\t\\ttoken.match[5] !== undefined ? token.match[5] : (\\n\\t\\t\\t\\t\\t\\t\\t\\ttoken.match[6] !== undefined ? token.match[6] : (\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\"\\\"\\n\\t\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t);\\n\\tif(token.match[1]) {\\n\\t\\tnode.name = token.match[1];\\n\\t}\\n\\t// Update the end position\\n\\tnode.end = pos;\\n\\treturn node;\\n};\\n\\n/*\\nLook for a macro invocation. Returns null if not found, or {type: \\\"macrocall\\\", name:, parameters:, start:, end:}\\n*/\\nexports.parseMacroInvocation = function(source,pos) {\\n\\tvar node = {\\n\\t\\ttype: \\\"macrocall\\\",\\n\\t\\tstart: pos,\\n\\t\\tparams: []\\n\\t};\\n\\t// Define our regexps\\n\\tvar reMacroName = /([^\\\\s>\\\"'=]+)/g;\\n\\t// Skip whitespace\\n\\tpos = $tw.utils.skipWhiteSpace(source,pos);\\n\\t// Look for a double less than sign\\n\\tvar token = $tw.utils.parseTokenString(source,pos,\\\"<<\\\");\\n\\tif(!token) {\\n\\t\\treturn null;\\n\\t}\\n\\tpos = token.end;\\n\\t// Get the macro name\\n\\tvar name = $tw.utils.parseTokenRegExp(source,pos,reMacroName);\\n\\tif(!name) {\\n\\t\\treturn null;\\n\\t}\\n\\tnode.name = name.match[1];\\n\\tpos = name.end;\\n\\t// Process parameters\\n\\tvar parameter = $tw.utils.parseMacroParameter(source,pos);\\n\\twhile(parameter) {\\n\\t\\tnode.params.push(parameter);\\n\\t\\tpos = parameter.end;\\n\\t\\t// Get the next parameter\\n\\t\\tparameter = $tw.utils.parseMacroParameter(source,pos);\\n\\t}\\n\\t// Skip whitespace\\n\\tpos = $tw.utils.skipWhiteSpace(source,pos);\\n\\t// Look for a double greater than sign\\n\\ttoken = $tw.utils.parseTokenString(source,pos,\\\">>\\\");\\n\\tif(!token) {\\n\\t\\treturn null;\\n\\t}\\n\\tpos = token.end;\\n\\t// Update the end position\\n\\tnode.end = pos;\\n\\treturn node;\\n};\\n\\n/*\\nLook for an HTML attribute definition. Returns null if not found, otherwise returns {type: \\\"attribute\\\", name:, valueType: \\\"string|indirect|macro\\\", value:, start:, end:,}\\n*/\\nvar AttributeRules = null;\\n\\nexports.parseAttribute = function(source,pos) {\\n\\tvar node = {\\n\\t\\tstart: pos\\n\\t};\\n\\t// Define our regexps\\n\\tvar reAttributeName = /([^\\\\/\\\\s>\\\"'=]+)/g,\\n\\t\\treUnquotedAttribute = /([^\\\\/\\\\s<>\\\"'=]+)/g,\\n\\t\\treFilteredValue = /\\\\{\\\\{\\\\{(.+?)\\\\}\\\\}\\\\}/g,\\n\\t\\treIndirectValue = /\\\\{\\\\{([^\\\\}]+)\\\\}\\\\}/g;\\n\\t// Skip whitespace\\n\\tpos = $tw.utils.skipWhiteSpace(source,pos);\\n\\t// Get the attribute name\\n\\tvar name = $tw.utils.parseTokenRegExp(source,pos,reAttributeName);\\n\\tif(!name) {\\n\\t\\treturn null;\\n\\t}\\n\\tnode.name = name.match[1];\\n\\tpos = name.end;\\n\\t// Skip whitespace\\n\\tpos = $tw.utils.skipWhiteSpace(source,pos);\\n\\t// Look for an equals sign\\n\\tvar token = $tw.utils.parseTokenString(source,pos,\\\"=\\\");\\n\\tif(token) {\\n\\t\\tpos = token.end;\\n\\t\\t// Skip whitespace\\n\\t\\tpos = $tw.utils.skipWhiteSpace(source,pos);\\n\\t\\t// Look for a string literal\\n\\t\\tvar stringLiteral = $tw.utils.parseStringLiteral(source,pos);\\n\\t\\tif(stringLiteral) {\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tnode.type = \\\"string\\\";\\n\\t\\t\\tnode.value = stringLiteral.value;\\n\\t\\t\\tnode.end = stringLiteral.end;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\treturn node;\\n\\t\\t}\\n\\t\\t// Load attribute rules if needed\\n\\t\\tif (!AttributeRules) {\\n\\t\\t\\tAttributeRules = {};\\n\\t\\t\\t$tw.modules.applyMethods(\\\"attributerule\\\",AttributeRules);\\n\\t\\t}\\n\\t\\t// Look for an attribute rule\\n\\t\\tvar match = null;\\n\\t\\t$tw.utils.each(AttributeRules,function(rule) {\\n\\t\\t\\tmatch = rule(source,pos,node);\\n\\t\\t\\treturn !match;\\n\\t\\t});\\n\\t\\tif (match) return match;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t// Look for a unquoted value\\n\\t\\tvar unquotedValue = $tw.utils.parseTokenRegExp(source,pos,reUnquotedAttribute);\\n\\t\\tif(unquotedValue) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tnode.type = \\\"string\\\";\\n\\t\\t\\tnode.value = unquotedValue.match[1];\\n\\t\\t\\tnode.end = unquotedValue.end;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\treturn node;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t} else {\\n\\t\\t\\tnode.type = \\\"string\\\";\\n\\t\\t\\tnode.value = \\\"true\\\";\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\n\\t\\n\\t} else {\\n\\t\\tnode.type = \\\"string\\\";\\n\\t\\tnode.value = \\\"true\\\";\\n\\t}\\n\\t// Update the end position\\n\\tnode.end = pos;\\n\\treturn node;\\n};\\n\\n})();\\n\\t\",\n            \"type\": \"_application/javascript\",\n            \"module-type\": \"_utils\"\n        },\n        \"$:/plugins/ebalster/attribute-modules/patchSource/core/modules/widgets/widget.js\": {\n            \"title\": \"$:/plugins/ebalster/attribute-modules/patchSource/core/modules/widgets/widget.js\",\n            \"text\": \"/*\\\\\\r\\ntitle: $:/core/modules/widgets/widget.js\\r\\ntype: application/javascript\\r\\nmodule-type: widget\\r\\n\\r\\nWidget base class\\r\\n\\r\\n\\\\*/\\r\\n(function(){\\r\\n\\r\\n/*jslint node: true, browser: true */\\r\\n/*global $tw: false */\\r\\n\\\"use strict\\\";\\r\\n\\r\\n/*\\r\\nCreate a widget object for a parse tree node\\r\\n\\tparseTreeNode: reference to the parse tree node to be rendered\\r\\n\\toptions: see below\\r\\nOptions include:\\r\\n\\twiki: mandatory reference to wiki associated with this render tree\\r\\n\\tparentWidget: optional reference to a parent renderer node for the context chain\\r\\n\\tdocument: optional document object to use instead of global document\\r\\n*/\\r\\nvar Widget = function(parseTreeNode,options) {\\r\\n\\tthis.initialise(parseTreeNode,options);\\r\\n};\\r\\n\\r\\n/*\\r\\nInitialise widget properties. These steps are pulled out of the constructor so that we can reuse them in subclasses\\r\\n*/\\r\\nWidget.prototype.initialise = function(parseTreeNode,options) {\\r\\n\\t// Bail if parseTreeNode is undefined, meaning  that the widget constructor was called without any arguments so that it can be subclassed\\r\\n\\tif(parseTreeNode === undefined) {\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\toptions = options || {};\\r\\n\\t// Save widget info\\r\\n\\tthis.parseTreeNode = parseTreeNode;\\r\\n\\tthis.wiki = options.wiki;\\r\\n\\tthis.parentWidget = options.parentWidget;\\r\\n\\tthis.variablesConstructor = function() {};\\r\\n\\tthis.variablesConstructor.prototype = this.parentWidget ? this.parentWidget.variables : {};\\r\\n\\tthis.variables = new this.variablesConstructor();\\r\\n\\tthis.document = options.document;\\r\\n\\tthis.attributes = {};\\r\\n\\tthis.children = [];\\r\\n\\tthis.domNodes = [];\\r\\n\\tthis.eventListeners = {};\\r\\n\\t// Hashmap of the widget classes\\r\\n\\tif(!this.widgetClasses) {\\r\\n\\t\\t// Get widget classes\\r\\n\\t\\tWidget.prototype.widgetClasses = $tw.modules.applyMethods(\\\"widget\\\");\\r\\n\\t\\t// Process any subclasses\\r\\n\\t\\t$tw.modules.forEachModuleOfType(\\\"widget-subclass\\\",function(title,module) {\\r\\n\\t\\t\\tif(module.baseClass) {\\r\\n\\t\\t\\t\\tvar baseClass = Widget.prototype.widgetClasses[module.baseClass];\\r\\n\\t\\t\\t\\tif(!baseClass) {\\r\\n\\t\\t\\t\\t\\tthrow \\\"Module '\\\" + title + \\\"' is attemping to extend a non-existent base class '\\\" + module.baseClass + \\\"'\\\";\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tvar subClass = module.constructor;\\r\\n\\t\\t\\t\\tsubClass.prototype = new baseClass();\\r\\n\\t\\t\\t\\t$tw.utils.extend(subClass.prototype,module.prototype);\\r\\n\\t\\t\\t\\tWidget.prototype.widgetClasses[module.name || module.baseClass] = subClass;\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\t// Hashmap of the attribute classes\\r\\n\\tif(!this.attributeClasses) {\\r\\n\\t\\tWidget.prototype.attributeClasses = $tw.modules.applyMethods(\\\"attributevalue\\\");\\r\\n\\t}\\r\\n};\\r\\n\\r\\n/*\\r\\nRender this widget into the DOM\\r\\n*/\\r\\nWidget.prototype.render = function(parent,nextSibling) {\\r\\n\\tthis.parentDomNode = parent;\\r\\n\\tthis.execute();\\r\\n\\tthis.renderChildren(parent,nextSibling);\\r\\n};\\r\\n\\r\\n/*\\r\\nCompute the internal state of the widget\\r\\n*/\\r\\nWidget.prototype.execute = function() {\\r\\n\\tthis.makeChildWidgets();\\r\\n};\\r\\n\\r\\n/*\\r\\nSet the value of a context variable\\r\\nname: name of the variable\\r\\nvalue: value of the variable\\r\\nparams: array of {name:, default:} for each parameter\\r\\nisMacroDefinition: true if the variable is set via a \\\\define macro pragma (and hence should have variable substitution performed)\\r\\n*/\\r\\nWidget.prototype.setVariable = function(name,value,params,isMacroDefinition) {\\r\\n\\tthis.variables[name] = {value: value, params: params, isMacroDefinition: !!isMacroDefinition};\\r\\n};\\r\\n\\r\\n/*\\r\\nGet the prevailing value of a context variable\\r\\nname: name of variable\\r\\noptions: see below\\r\\nOptions include\\r\\nparams: array of {name:, value:} for each parameter\\r\\ndefaultValue: default value if the variable is not defined\\r\\n\\r\\nReturns an object with the following fields:\\r\\n\\r\\nparams: array of {name:,value:} of parameters passed to wikitext variables\\r\\ntext: text of variable, with parameters properly substituted\\r\\n*/\\r\\nWidget.prototype.getVariableInfo = function(name,options) {\\r\\n\\toptions = options || {};\\r\\n\\tvar actualParams = options.params || [],\\r\\n\\t\\tparentWidget = this.parentWidget;\\r\\n\\t// Check for the variable defined in the parent widget (or an ancestor in the prototype chain)\\r\\n\\tif(parentWidget && name in parentWidget.variables) {\\r\\n\\t\\tvar variable = parentWidget.variables[name],\\r\\n\\t\\t\\toriginalValue = variable.value,\\r\\n\\t\\t\\tvalue = originalValue,\\r\\n\\t\\t\\tparams = this.resolveVariableParameters(variable.params,actualParams);\\r\\n\\t\\t// Substitute any parameters specified in the definition\\r\\n\\t\\t$tw.utils.each(params,function(param) {\\r\\n\\t\\t\\tvalue = $tw.utils.replaceString(value,new RegExp(\\\"\\\\\\\\$\\\" + $tw.utils.escapeRegExp(param.name) + \\\"\\\\\\\\$\\\",\\\"mg\\\"),param.value);\\r\\n\\t\\t});\\r\\n\\t\\t// Only substitute variable references if this variable was defined with the \\\\define pragma\\r\\n\\t\\tif(variable.isMacroDefinition) {\\r\\n\\t\\t\\tvalue = this.substituteVariableReferences(value);\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\treturn {\\r\\n\\t\\t\\ttext: value,\\r\\n\\t\\t\\tparams: params,\\r\\n\\t\\t\\tsrcVariable: variable,\\r\\n\\t\\t\\tisCacheable: originalValue === value\\r\\n\\t\\t};\\r\\n\\t}\\r\\n\\t// If the variable doesn't exist in the parent widget then look for a macro module\\r\\n\\treturn {\\r\\n\\t\\ttext: this.evaluateMacroModule(name,actualParams,options.defaultValue)\\r\\n\\t};\\r\\n};\\r\\n\\r\\n/*\\r\\nSimplified version of getVariableInfo() that just returns the text\\r\\n*/\\r\\nWidget.prototype.getVariable = function(name,options) {\\r\\n\\treturn this.getVariableInfo(name,options).text;\\r\\n};\\r\\n\\r\\nWidget.prototype.resolveVariableParameters = function(formalParams,actualParams) {\\r\\n\\tformalParams = formalParams || [];\\r\\n\\tactualParams = actualParams || [];\\r\\n\\tvar nextAnonParameter = 0, // Next candidate anonymous parameter in macro call\\r\\n\\t\\tparamInfo, paramValue,\\r\\n\\t\\tresults = [];\\r\\n\\t// Step through each of the parameters in the macro definition\\r\\n\\tfor(var p=0; p<formalParams.length; p++) {\\r\\n\\t\\t// Check if we've got a macro call parameter with the same name\\r\\n\\t\\tparamInfo = formalParams[p];\\r\\n\\t\\tparamValue = undefined;\\r\\n\\t\\tfor(var m=0; m<actualParams.length; m++) {\\r\\n\\t\\t\\tif(actualParams[m].name === paramInfo.name) {\\r\\n\\t\\t\\t\\tparamValue = actualParams[m].value;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t// If not, use the next available anonymous macro call parameter\\r\\n\\t\\twhile(nextAnonParameter < actualParams.length && actualParams[nextAnonParameter].name) {\\r\\n\\t\\t\\tnextAnonParameter++;\\r\\n\\t\\t}\\r\\n\\t\\tif(paramValue === undefined && nextAnonParameter < actualParams.length) {\\r\\n\\t\\t\\tparamValue = actualParams[nextAnonParameter++].value;\\r\\n\\t\\t}\\r\\n\\t\\t// If we've still not got a value, use the default, if any\\r\\n\\t\\tparamValue = paramValue || paramInfo[\\\"default\\\"] || \\\"\\\";\\r\\n\\t\\t// Store the parameter name and value\\r\\n\\t\\tresults.push({name: paramInfo.name, value: paramValue});\\r\\n\\t}\\r\\n\\treturn results;\\r\\n};\\r\\n\\r\\nWidget.prototype.substituteVariableReferences = function(text) {\\r\\n\\tvar self = this;\\r\\n\\treturn (text || \\\"\\\").replace(/\\\\$\\\\(([^\\\\)\\\\$]+)\\\\)\\\\$/g,function(match,p1,offset,string) {\\r\\n\\t\\treturn self.getVariable(p1,{defaultValue: \\\"\\\"});\\r\\n\\t});\\r\\n};\\r\\n\\r\\nWidget.prototype.evaluateMacroModule = function(name,actualParams,defaultValue) {\\r\\n\\tif($tw.utils.hop($tw.macros,name)) {\\r\\n\\t\\tvar macro = $tw.macros[name],\\r\\n\\t\\t\\targs = [];\\r\\n\\t\\tif(macro.params.length > 0) {\\r\\n\\t\\t\\tvar nextAnonParameter = 0, // Next candidate anonymous parameter in macro call\\r\\n\\t\\t\\t\\tparamInfo, paramValue;\\r\\n\\t\\t\\t// Step through each of the parameters in the macro definition\\r\\n\\t\\t\\tfor(var p=0; p<macro.params.length; p++) {\\r\\n\\t\\t\\t\\t// Check if we've got a macro call parameter with the same name\\r\\n\\t\\t\\t\\tparamInfo = macro.params[p];\\r\\n\\t\\t\\t\\tparamValue = undefined;\\r\\n\\t\\t\\t\\tfor(var m=0; m<actualParams.length; m++) {\\r\\n\\t\\t\\t\\t\\tif(actualParams[m].name === paramInfo.name) {\\r\\n\\t\\t\\t\\t\\t\\tparamValue = actualParams[m].value;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t// If not, use the next available anonymous macro call parameter\\r\\n\\t\\t\\t\\twhile(nextAnonParameter < actualParams.length && actualParams[nextAnonParameter].name) {\\r\\n\\t\\t\\t\\t\\tnextAnonParameter++;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(paramValue === undefined && nextAnonParameter < actualParams.length) {\\r\\n\\t\\t\\t\\t\\tparamValue = actualParams[nextAnonParameter++].value;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t// If we've still not got a value, use the default, if any\\r\\n\\t\\t\\t\\tparamValue = paramValue || paramInfo[\\\"default\\\"] || \\\"\\\";\\r\\n\\t\\t\\t\\t// Save the parameter\\r\\n\\t\\t\\t\\targs.push(paramValue);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\telse for(var i=0; i<actualParams.length; ++i) {\\r\\n\\t\\t\\targs.push(actualParams[i].value);\\r\\n\\t\\t}\\r\\n\\t\\treturn (macro.run.apply(this,args) || \\\"\\\").toString();\\r\\n\\t} else {\\r\\n\\t\\treturn defaultValue;\\r\\n\\t}\\r\\n};\\r\\n\\r\\n/*\\r\\nCheck whether a given context variable value exists in the parent chain\\r\\n*/\\r\\nWidget.prototype.hasVariable = function(name,value) {\\r\\n\\tvar node = this;\\r\\n\\twhile(node) {\\r\\n\\t\\tif($tw.utils.hop(node.variables,name) && node.variables[name].value === value) {\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\t\\tnode = node.parentWidget;\\r\\n\\t}\\r\\n\\treturn false;\\r\\n};\\r\\n\\r\\n/*\\r\\nConstruct a qualifying string based on a hash of concatenating the values of a given variable in the parent chain\\r\\n*/\\r\\nWidget.prototype.getStateQualifier = function(name) {\\r\\n\\tthis.qualifiers = this.qualifiers || Object.create(null);\\r\\n\\tname = name || \\\"transclusion\\\";\\r\\n\\tif(this.qualifiers[name]) {\\r\\n\\t\\treturn this.qualifiers[name];\\r\\n\\t} else {\\r\\n\\t\\tvar output = [],\\r\\n\\t\\t\\tnode = this;\\r\\n\\t\\twhile(node && node.parentWidget) {\\r\\n\\t\\t\\tif($tw.utils.hop(node.parentWidget.variables,name)) {\\r\\n\\t\\t\\t\\toutput.push(node.getVariable(name));\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tnode = node.parentWidget;\\r\\n\\t\\t}\\r\\n\\t\\tvar value = $tw.utils.hashString(output.join(\\\"\\\"));\\r\\n\\t\\tthis.qualifiers[name] = value;\\r\\n\\t\\treturn value;\\r\\n\\t}\\r\\n};\\r\\n\\r\\n/*\\r\\nCompute the current values of the attributes of the widget. Returns a hashmap of the names of the attributes that have changed\\r\\n*/\\r\\nWidget.prototype.computeAttributes = function() {\\r\\n\\tvar changedAttributes = {},\\r\\n\\t\\tself = this,\\r\\n\\t\\tvalue;\\r\\n\\tif (!this.attributeGizmos) {\\r\\n\\t\\t// First-time attribute preparation\\r\\n\\t\\tthis.attributeGizmos = {};\\r\\n\\t\\t$tw.utils.each(this.parseTreeNode.attributes,function(attribute,name) {\\r\\n\\t\\t\\t// Does the attribute type have a known module?\\r\\n\\t\\t\\tvar AttributeClass = self.attributeClasses[attribute.type];\\r\\n\\t\\t\\tif (AttributeClass) {\\r\\n\\t\\t\\t\\t// Instantiate an attribute object.\\r\\n\\t\\t\\t\\tself.attributeGizmos[name] = new AttributeClass(self,attribute);\\r\\n\\t\\t\\t\\tvalue = self.attributeGizmos[name].value;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse {\\r\\n\\t\\t\\t\\t// Unknown attribute types are treated as strings.\\r\\n\\t\\t\\t\\t// String attributes don't change after the first computeAttributes().\\r\\n\\t\\t\\t\\tvalue = attribute.value;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t// Is the value changed?\\r\\n\\t\\t\\tif (self.attributes[name] !== value) {\\r\\n\\t\\t\\t\\tself.attributes[name] = value;\\r\\n\\t\\t\\t\\tchangedAttributes[name] = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t});\\r\\n\\t}else {\\r\\n\\t\\t// Fully recompute all dynamic attributes (no selectivity is available)\\r\\n\\t\\t$tw.utils.each(this.attributeGizmos,function(gizmo,name) {\\r\\n\\t\\t\\tvalue = gizmo.compute();\\r\\n\\t\\t\\tif(self.attributes[name] !== value) {\\r\\n\\t\\t\\t\\tself.attributes[name] = value;\\r\\n\\t\\t\\t\\tchangedAttributes[name] = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\treturn changedAttributes;\\r\\n};\\r\\n\\r\\n/*\\r\\nSelectively re-compute previously computed attributes. Returns a hashmap of the names of the attributes that have changed\\r\\n*/\\r\\nWidget.prototype.refreshAttributes = function(changedTiddlers) {\\r\\n\\tif (!this.attributeGizmos) return computeAttributes();\\r\\n\\tvar changedAttributes = {},\\r\\n\\t\\tself = this,\\r\\n\\t\\tvalue;\\r\\n\\t// Fully recompute all dynamic attributes (no selectivity is available)\\r\\n\\t$tw.utils.each(this.attributeGizmos,function(gizmo,name) {\\r\\n\\t\\tvalue = gizmo.refresh(changedTiddlers);\\r\\n\\t\\tif(self.attributes[name] !== value) {\\r\\n\\t\\t\\tself.attributes[name] = value;\\r\\n\\t\\t\\tchangedAttributes[name] = true;\\r\\n\\t\\t}\\r\\n\\t});\\r\\n\\treturn changedAttributes;\\r\\n};\\r\\n\\r\\n/*\\r\\nCheck for the presence of an attribute\\r\\n*/\\r\\nWidget.prototype.hasAttribute = function(name) {\\r\\n\\treturn $tw.utils.hop(this.attributes,name);\\r\\n};\\r\\n\\r\\n/*\\r\\nGet the value of an attribute\\r\\n*/\\r\\nWidget.prototype.getAttribute = function(name,defaultText) {\\r\\n\\tif($tw.utils.hop(this.attributes,name)) {\\r\\n\\t\\treturn this.attributes[name];\\r\\n\\t} else {\\r\\n\\t\\treturn defaultText;\\r\\n\\t}\\r\\n};\\r\\n\\r\\n/*\\r\\nAssign the computed attributes of the widget to a domNode\\r\\noptions include:\\r\\nexcludeEventAttributes: ignores attributes whose name begins with \\\"on\\\"\\r\\n*/\\r\\nWidget.prototype.assignAttributes = function(domNode,options) {\\r\\n\\toptions = options || {};\\r\\n\\tvar self = this;\\r\\n\\t$tw.utils.each(this.attributes,function(v,a) {\\r\\n\\t\\t// Check exclusions\\r\\n\\t\\tif(options.excludeEventAttributes && a.substr(0,2) === \\\"on\\\") {\\r\\n\\t\\t\\tv = undefined;\\r\\n\\t\\t}\\r\\n\\t\\tif(v !== undefined) {\\r\\n\\t\\t\\tvar b = a.split(\\\":\\\");\\r\\n\\t\\t\\t// Setting certain attributes can cause a DOM error (eg xmlns on the svg element)\\r\\n\\t\\t\\ttry {\\r\\n\\t\\t\\t\\tif (b.length == 2 && b[0] == \\\"xlink\\\"){\\r\\n\\t\\t\\t\\t\\tdomNode.setAttributeNS(\\\"http://www.w3.org/1999/xlink\\\",b[1],v);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tdomNode.setAttributeNS(null,a,v);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} catch(e) {\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t});\\r\\n};\\r\\n\\r\\n/*\\r\\nMake child widgets correspondng to specified parseTreeNodes\\r\\n*/\\r\\nWidget.prototype.makeChildWidgets = function(parseTreeNodes) {\\r\\n\\tthis.children = [];\\r\\n\\tvar self = this;\\r\\n\\t$tw.utils.each(parseTreeNodes || (this.parseTreeNode && this.parseTreeNode.children),function(childNode) {\\r\\n\\t\\tself.children.push(self.makeChildWidget(childNode));\\r\\n\\t});\\r\\n};\\r\\n\\r\\n/*\\r\\nConstruct the widget object for a parse tree node\\r\\n*/\\r\\nWidget.prototype.makeChildWidget = function(parseTreeNode) {\\r\\n\\tvar WidgetClass = this.widgetClasses[parseTreeNode.type];\\r\\n\\tif(!WidgetClass) {\\r\\n\\t\\tWidgetClass = this.widgetClasses.text;\\r\\n\\t\\tparseTreeNode = {type: \\\"text\\\", text: \\\"Undefined widget '\\\" + parseTreeNode.type + \\\"'\\\"};\\r\\n\\t}\\r\\n\\treturn new WidgetClass(parseTreeNode,{\\r\\n\\t\\twiki: this.wiki,\\r\\n\\t\\tvariables: {},\\r\\n\\t\\tparentWidget: this,\\r\\n\\t\\tdocument: this.document\\r\\n\\t});\\r\\n};\\r\\n\\r\\n/*\\r\\nGet the next sibling of this widget\\r\\n*/\\r\\nWidget.prototype.nextSibling = function() {\\r\\n\\tif(this.parentWidget) {\\r\\n\\t\\tvar index = this.parentWidget.children.indexOf(this);\\r\\n\\t\\tif(index !== -1 && index < this.parentWidget.children.length-1) {\\r\\n\\t\\t\\treturn this.parentWidget.children[index+1];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn null;\\r\\n};\\r\\n\\r\\n/*\\r\\nGet the previous sibling of this widget\\r\\n*/\\r\\nWidget.prototype.previousSibling = function() {\\r\\n\\tif(this.parentWidget) {\\r\\n\\t\\tvar index = this.parentWidget.children.indexOf(this);\\r\\n\\t\\tif(index !== -1 && index > 0) {\\r\\n\\t\\t\\treturn this.parentWidget.children[index-1];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn null;\\r\\n};\\r\\n\\r\\n/*\\r\\nRender the children of this widget into the DOM\\r\\n*/\\r\\nWidget.prototype.renderChildren = function(parent,nextSibling) {\\r\\n\\tvar children = this.children;\\r\\n\\tfor(var i = 0; i < children.length; i++) {\\r\\n\\t\\tchildren[i].render(parent,nextSibling);\\r\\n\\t};\\r\\n};\\r\\n\\r\\n/*\\r\\nAdd a list of event listeners from an array [{type:,handler:},...]\\r\\n*/\\r\\nWidget.prototype.addEventListeners = function(listeners) {\\r\\n\\tvar self = this;\\r\\n\\t$tw.utils.each(listeners,function(listenerInfo) {\\r\\n\\t\\tself.addEventListener(listenerInfo.type,listenerInfo.handler);\\r\\n\\t});\\r\\n};\\r\\n\\r\\n/*\\r\\nAdd an event listener\\r\\n*/\\r\\nWidget.prototype.addEventListener = function(type,handler) {\\r\\n\\tvar self = this;\\r\\n\\tif(typeof handler === \\\"string\\\") { // The handler is a method name on this widget\\r\\n\\t\\tthis.eventListeners[type] = function(event) {\\r\\n\\t\\t\\treturn self[handler].call(self,event);\\r\\n\\t\\t};\\r\\n\\t} else { // The handler is a function\\r\\n\\t\\tthis.eventListeners[type] = function(event) {\\r\\n\\t\\t\\treturn handler.call(self,event);\\r\\n\\t\\t};\\r\\n\\t}\\r\\n};\\r\\n\\r\\n/*\\r\\nDispatch an event to a widget. If the widget doesn't handle the event then it is also dispatched to the parent widget\\r\\n*/\\r\\nWidget.prototype.dispatchEvent = function(event) {\\r\\n\\tevent.widget = event.widget || this;\\r\\n\\t// Dispatch the event if this widget handles it\\r\\n\\tvar listener = this.eventListeners[event.type];\\r\\n\\tif(listener) {\\r\\n\\t\\t// Don't propagate the event if the listener returned false\\r\\n\\t\\tif(!listener(event)) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t// Dispatch the event to the parent widget\\r\\n\\tif(this.parentWidget) {\\r\\n\\t\\treturn this.parentWidget.dispatchEvent(event);\\r\\n\\t}\\r\\n\\treturn true;\\r\\n};\\r\\n\\r\\n/*\\r\\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\r\\n*/\\r\\nWidget.prototype.refresh = function(changedTiddlers) {\\r\\n\\treturn this.refreshChildren(changedTiddlers);\\r\\n};\\r\\n\\r\\n/*\\r\\nRebuild a previously rendered widget\\r\\n*/\\r\\nWidget.prototype.refreshSelf = function() {\\r\\n\\tvar nextSibling = this.findNextSiblingDomNode();\\r\\n\\tthis.removeChildDomNodes();\\r\\n\\tthis.render(this.parentDomNode,nextSibling);\\r\\n};\\r\\n\\r\\n/*\\r\\nRefresh all the children of a widget\\r\\n*/\\r\\nWidget.prototype.refreshChildren = function(changedTiddlers) {\\r\\n\\tvar children = this.children,\\r\\n\\t\\trefreshed = false;\\r\\n\\tfor (var i = 0; i < children.length; i++) {\\r\\n\\t\\trefreshed = children[i].refresh(changedTiddlers) || refreshed;\\r\\n\\t}\\r\\n\\treturn refreshed;\\r\\n};\\r\\n\\r\\n/*\\r\\nFind the next sibling in the DOM to this widget. This is done by scanning the widget tree through all next siblings and their descendents that share the same parent DOM node\\r\\n*/\\r\\nWidget.prototype.findNextSiblingDomNode = function(startIndex) {\\r\\n\\t// Refer to this widget by its index within its parents children\\r\\n\\tvar parent = this.parentWidget,\\r\\n\\t\\tindex = startIndex !== undefined ? startIndex : parent.children.indexOf(this);\\r\\nif(index === -1) {\\r\\n\\tthrow \\\"node not found in parents children\\\";\\r\\n}\\r\\n\\t// Look for a DOM node in the later siblings\\r\\n\\twhile(++index < parent.children.length) {\\r\\n\\t\\tvar domNode = parent.children[index].findFirstDomNode();\\r\\n\\t\\tif(domNode) {\\r\\n\\t\\t\\treturn domNode;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t// Go back and look for later siblings of our parent if it has the same parent dom node\\r\\n\\tvar grandParent = parent.parentWidget;\\r\\n\\tif(grandParent && parent.parentDomNode === this.parentDomNode) {\\r\\n\\t\\tindex = grandParent.children.indexOf(parent);\\r\\n\\t\\tif(index !== -1) {\\r\\n\\t\\t\\treturn parent.findNextSiblingDomNode(index);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn null;\\r\\n};\\r\\n\\r\\n/*\\r\\nFind the first DOM node generated by a widget or its children\\r\\n*/\\r\\nWidget.prototype.findFirstDomNode = function() {\\r\\n\\t// Return the first dom node of this widget, if we've got one\\r\\n\\tif(this.domNodes.length > 0) {\\r\\n\\t\\treturn this.domNodes[0];\\r\\n\\t}\\r\\n\\t// Otherwise, recursively call our children\\r\\n\\tfor(var t=0; t<this.children.length; t++) {\\r\\n\\t\\tvar domNode = this.children[t].findFirstDomNode();\\r\\n\\t\\tif(domNode) {\\r\\n\\t\\t\\treturn domNode;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn null;\\r\\n};\\r\\n\\r\\n/*\\r\\nRemove any DOM nodes created by this widget or its children\\r\\n*/\\r\\nWidget.prototype.removeChildDomNodes = function() {\\r\\n\\t// If this widget has directly created DOM nodes, delete them and exit. This assumes that any child widgets are contained within the created DOM nodes, which would normally be the case\\r\\n\\tif(this.domNodes.length > 0) {\\r\\n\\t\\t$tw.utils.each(this.domNodes,function(domNode) {\\r\\n\\t\\t\\tdomNode.parentNode.removeChild(domNode);\\r\\n\\t\\t});\\r\\n\\t\\tthis.domNodes = [];\\r\\n\\t} else {\\r\\n\\t\\t// Otherwise, ask the child widgets to delete their DOM nodes\\r\\n\\t\\t$tw.utils.each(this.children,function(childWidget) {\\r\\n\\t\\t\\tchildWidget.removeChildDomNodes();\\r\\n\\t\\t});\\r\\n\\t}\\r\\n};\\r\\n\\r\\n/*\\r\\nInvoke the action widgets that are descendents of the current widget.\\r\\n*/\\r\\nWidget.prototype.invokeActions = function(triggeringWidget,event) {\\r\\n\\tvar handled = false;\\r\\n\\t// For each child widget\\r\\n\\tfor(var t=0; t<this.children.length; t++) {\\r\\n\\t\\tvar child = this.children[t];\\r\\n\\t\\t// Invoke the child if it is an action widget\\r\\n\\t\\tif(child.invokeAction) {\\r\\n\\t\\t\\tchild.refreshSelf();\\r\\n\\t\\t\\tif(child.invokeAction(triggeringWidget,event)) {\\r\\n\\t\\t\\t\\thandled = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t// Propagate through through the child if it permits it\\r\\n\\t\\tif(child.allowActionPropagation() && child.invokeActions(triggeringWidget,event)) {\\r\\n\\t\\t\\thandled = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn handled;\\r\\n};\\r\\n\\r\\n/*\\r\\nInvoke the action widgets defined in a string\\r\\n*/\\r\\nWidget.prototype.invokeActionString = function(actions,triggeringWidget,event,variables) {\\r\\n\\tactions = actions || \\\"\\\";\\r\\n\\tvar parser = this.wiki.parseText(\\\"text/vnd.tiddlywiki\\\",actions,{\\r\\n\\t\\t\\tparentWidget: this,\\r\\n\\t\\t\\tdocument: this.document\\r\\n\\t\\t}),\\r\\n\\t\\twidgetNode = this.wiki.makeWidget(parser,{\\r\\n\\t\\t\\tparentWidget: this,\\r\\n\\t\\t\\tdocument: this.document,\\r\\n\\t\\t\\tvariables: variables\\r\\n\\t\\t});\\r\\n\\tvar container = this.document.createElement(\\\"div\\\");\\r\\n\\twidgetNode.render(container,null);\\r\\n\\treturn widgetNode.invokeActions(this,event);\\r\\n};\\r\\n\\r\\n/*\\r\\nExecute action tiddlers by tag\\r\\n*/\\r\\nWidget.prototype.invokeActionsByTag = function(tag,event,variables) {\\r\\n\\tvar self = this;\\r\\n\\t$tw.utils.each(self.wiki.filterTiddlers(\\\"[all[shadows+tiddlers]tag[\\\" + tag + \\\"]!has[draft.of]]\\\"),function(title) {\\r\\n\\t\\tself.invokeActionString(self.wiki.getTiddlerText(title),self,event,variables);\\r\\n\\t});\\r\\n};\\r\\n\\r\\nWidget.prototype.allowActionPropagation = function() {\\r\\n\\treturn true;\\r\\n};\\r\\n\\r\\nexports.widget = Widget;\\r\\n\\r\\n})();\\r\\n\",\n            \"type\": \"_application/javascript\",\n            \"module-type\": \"_widget\"\n        },\n        \"$:/plugins/ebalster/attribute-modules/patch/core/modules/utils/parseutils.js\": {\n            \"title\": \"$:/plugins/ebalster/attribute-modules/patch/core/modules/utils/parseutils.js\",\n            \"text\": \"@@ -79,33 +79,35 @@\\n dule-type: utils\\n-%0A\\n+%0D%0A%0D\\n %0AUtility functio\\n@@ -141,33 +141,35 @@\\n ext into tokens.\\n-%0A\\n+%0D%0A%0D\\n %0AMost functions \\n@@ -187,33 +187,35 @@\\n llowing pattern:\\n-%0A\\n+%0D%0A%0D\\n %0A* The parameter\\n@@ -771,33 +771,35 @@\\n scribe the token\\n-%0A\\n+%0D%0A%0D\\n %0AThe exception i\\n@@ -863,33 +863,35 @@\\n  the whitespace.\\n-%0A\\n+%0D%0A%0D\\n %0A%5C*/%0A(function()\\n@@ -883,33 +883,35 @@\\n %5C*/%0A(function()%7B\\n-%0A\\n+%0D%0A%0D\\n %0A/*jslint node: \\n@@ -961,33 +961,35 @@\\n */%0A%22use strict%22;\\n-%0A\\n+%0D%0A%0D\\n %0A/*%0ALook for a w\\n@@ -1490,33 +1490,35 @@\\n end: p%0A%09%09%7D%0A%09%7D%0A%7D;\\n-%0A\\n+%0D%0A%0D\\n %0A/*%0AConvenience \\n@@ -1884,33 +1884,35 @@\\n n pos;%0A%09%09%7D%0A%09%7D%0A%7D;\\n-%0A\\n+%0D%0A%0D\\n %0A/*%0ALook for a g\\n@@ -2238,33 +2238,35 @@\\n %09return null;%0A%7D;\\n-%0A\\n+%0D%0A%0D\\n %0A/*%0ALook for a t\\n@@ -2669,33 +2669,35 @@\\n turn null;%0A%09%7D%0A%7D;\\n-%0A\\n+%0D%0A%0D\\n %0A/*%0ALook for a s\\n@@ -3246,33 +3246,35 @@\\n turn null;%0A%09%7D%0A%7D;\\n-%0A\\n+%0D%0A%0D\\n %0A/*%0ALook for a m\\n@@ -4346,33 +4346,35 @@\\n %09return node;%0A%7D;\\n-%0A\\n+%0D%0A%0D\\n %0A/*%0ALook for a m\\n@@ -5536,33 +5536,35 @@\\n %09return node;%0A%7D;\\n-%0A\\n+%0D%0A%0D\\n %0A/*%0ALook for an \\n@@ -5716,32 +5716,62 @@\\n art:, end:,%7D%0A*/%0A\\n+var AttributeRules = null;%0D%0A%0D%0A\\n exports.parseAtt\\n@@ -6630,40 +6630,20 @@\\n l) %7B%0A%09%09%09\\n-pos = stringLiteral.end;\\n+%09%09%09%09\\n %0A%09%09%09node\\n@@ -6699,533 +6699,481 @@\\n alue;%0A%09%09\\n-%7D else %7B%0A%09%09%09// Look for a filtered value%0A%09%09%09var filteredValue = $tw.utils.parseTokenRegExp(source,pos,reFilteredValue);%0A%09%09%09if(filteredValue) %7B%0A%09%09%09%09pos = filteredValue.end;%0A%09%09%09%09node.type = %22filtered%22;%0A%09%09%09%09node.filter = filteredValue.match%5B1%5D;%0A%09%09%09%7D else %7B%0A%09%09%09%09// Look for an indirect value%0A%09%09%09%09var indirectValue = $tw.utils.parseTokenRegExp(source,pos,reIndirectValue);%0A%09%09%09%09if(indirectValue) %7B%0A%09%09%09%09%09pos = indirectValue.end;%0A%09%09%09%09%09node.type = %22indirect%22;%0A%09%09%09%09%09node.textReference = indirectValue.\\n+%09node.end = stringLiteral.end;%0A%09%09%09%09%09%09%09%09%0A%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%0A%09%09%09%09%09%09%0A%09%09%09%09%09%09%09%0A%09%09%09return node;%0A%09%09%7D%0A%09%09// Load attribute rules if needed%0A%09%09if (!AttributeRules) %7B%0A%09%09%09AttributeRules = %7B%7D;%0A%09%09%09$tw.modules.applyMethods(%22attributerule%22,AttributeRules);%0A%09%09%7D%0A%09%09// Look for an attribute rule%0A%09%09var match = null;%0A%09%09$tw.utils.each(AttributeRules,function(rule) %7B%0A%09%09%09match = rule(source,pos,node);%0A%09%09%09return !match;%0A%09%09%7D);%0A%09%09if (match) return \\n match\\n-%5B1%5D\\n ;%0A%09%09%09%09\\n-%7D else %7B\\n+%09%09%09%09%09%09%09%09%09\\n %0A%09%09%09\\n+%0A\\n %09%09// Loo\\n@@ -7187,35 +7187,32 @@\\n  unquoted value%0A\\n-%09%09%09\\n %09%09var unquotedVa\\n@@ -7269,35 +7269,32 @@\\n otedAttribute);%0A\\n-%09%09%09\\n %09%09if(unquotedVal\\n@@ -7304,45 +7304,20 @@\\n  %7B%0A%09%09%09%09%09\\n-%09pos = unquotedValue.end;%0A\\n %09%09%09\\n+%0A\\n %09%09%09node.\\n@@ -7325,35 +7325,32 @@\\n ype = %22string%22;%0A\\n-%09%09%09\\n %09%09%09node.value = \\n@@ -7376,288 +7376,156 @@\\n %5B1%5D;%0A%09%09%09\\n-%09%09%7D else %7B%0A%09%09%09%09%09%09// Look for a macro invocation value%0A%09%09%09%09%09%09var macroInvocation = $tw.utils.parseMacroInvocation(source,pos);%0A%09%09%09%09%09%09if(macroInvocation) %7B%0A%09%09%09%09%09%09%09pos = macroInvocation.end;%0A%09%09%09%09%09%09%09node.type = %22macro%22;%0A%09%09%09%09%09%09%09node.value = macroInvocation;%0A\\n+node.end = unquotedValue.end;%0A%09%09%09%09%09%09%09%09%09%09%09%0A%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%0A%09%09%09%09%09%09%09%0A%09%09%09%09%09%09%09%09%09%0A%09%09%09return node;%0A%09%09\\n %09%09%09%09\\n+%09%09%09%0A\\n %09%09%7D else %7B%0A\\n-%09%09%09%09\\n %09%09%09node.\\n@@ -7533,36 +7533,32 @@\\n ype = %22string%22;%0A\\n-%09%09%09%09\\n %09%09%09node.value = \\n@@ -7567,43 +7567,27 @@\\n rue%22;%0A%09%09\\n-%09%09%09%09%7D%0A%09%09%09%09%09%7D%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09%7D\\n+%7D%0A%09%09%0A%09%09%0A%09%0A%09\\n %0A%09%7D else\\n@@ -7700,16 +7700,19 @@\\n node;%0A%7D;\\n-%0A\\n+%0D%0A%0D\\n %0A%7D)();%0A\\n+%09\\n\",\n            \"created\": \"20200428232337462\",\n            \"modified\": \"20200428232337487\",\n            \"modloader-source\": \"$:/core\",\n            \"modloader-target\": \"$:/core/modules/utils/parseutils.js\",\n            \"type\": \"text/x-patch\"\n        },\n        \"$:/plugins/ebalster/attribute-modules/patch/core/modules/widgets/widget.js\": {\n            \"title\": \"$:/plugins/ebalster/attribute-modules/patch/core/modules/widgets/widget.js\",\n            \"text\": \"@@ -2240,32 +2240,184 @@\\n ;%0A%09%09%09%7D%0A%09%09%7D);%0A%09%7D%0A\\n+%09// Hashmap of the attribute classes%0A%09if(!this.attributeClasses) %7B%0A%09%09Widget.prototype.attributeClasses = $tw.modules.applyMethods(%22attributevalue%22);%0A%09%7D%0A\\n %7D;%0D%0A%0D%0A/*%0ARender \\n@@ -9043,32 +9043,130 @@\\n  this,%0A%09%09value;%0A\\n+%09if (!this.attributeGizmos) %7B%0A%09%09// First-time attribute preparation%0A%09%09this.attributeGizmos = %7B%7D;%0A%09\\n %09$tw.utils.each(\\n@@ -9224,501 +9224,1462 @@\\n me) %7B%0A%09%09\\n-if(\\n+%09// Does the \\n attribute\\n-.\\n+ \\n type \\n-=== %22filtered%22) %7B%0A%09%09%09value = self.wiki.filterTiddlers(attribute.filter,self)%5B0%5D %7C%7C %22%22;%0A%09%09%7D else if(attribute.type === %22indirect%22) %7B\\n+have a known module?%0A%09%09%09var AttributeClass = self.attributeClasses%5Battribute.type%5D;%0A%09%09%09if (AttributeClass) %7B%0A%09%09%09%09// Instantiate an attribute object.%0A%09%09%09%09self.attributeGizmos%5Bname%5D = new AttributeClass(self,attribute);\\n %0A%09%09%09\\n+%09\\n value = self.\\n-wiki.getTextReference(attribute.textReference,%22%22,self.getVariable(%22currentTiddler%22)\\n+attributeGizmos%5Bname%5D.value;%0A%09%09%09%7D%0A%09%09%09else %7B%0A%09%09%09%09// Unknown attribute types are treated as strings.%0A%09%09%09%09// String attributes don't change after the first computeAttributes().%0A%09%09%09%09value = attribute.value;%0A%09%09%09%7D%0A%09%09%09// Is the value changed?%0A%09%09%09if (self.attributes%5Bname%5D !== value) %7B%0A%09%09%09%09self.attributes%5Bname%5D = value;%0A%09%09%09%09changedAttributes%5Bname%5D = true;%0A%09%09%09%7D%0A%09%09%09return true;%0A%09%09%7D\\n );%0A\\n-%09\\n %09%7D\\n- \\n else \\n-if(attribute.type === %22macro%22) %7B%0A%09%09%09value = self.getVariable(attribute.value.name,%7Bparams: attribute.value.params%7D);%0A%09%09%7D else %7B // String attribute%0A%09%09%09value = attribute.value;%0A%09%09%7D%0A%09%09// Check whether the attribute has changed\\n+%7B%0A%09%09// Fully recompute all dynamic attributes (no selectivity is available)%0A%09%09$tw.utils.each(this.attributeGizmos,function(gizmo,name) %7B%0A%09%09%09value = gizmo.compute();%0A%09%09%09if(self.attributes%5Bname%5D !== value) %7B%0A%09%09%09%09self.attributes%5Bname%5D = value;%0A%09%09%09%09changedAttributes%5Bname%5D = true;%0A%09%09%09%7D%0A%09%09%7D);%0A%09%7D%0A%09return changedAttributes;%0A%7D;%0D%0A%0D%0A/*%0ASelectively re-compute previously computed attributes. Returns a hashmap of the names of the attributes that have changed%0A*/%0AWidget.prototype.refreshAttributes = function(changedTiddlers) %7B%0A%09if (!this.attributeGizmos) return computeAttributes();%0A%09var changedAttributes = %7B%7D,%0A%09%09self = this,%0A%09%09value;%0A%09// Fully recompute all dynamic attributes (no selectivity is available)%0A%09$tw.utils.each(this.attributeGizmos,function(gizmo,name) %7B%0A%09%09value = gizmo.refresh(changedTiddlers);\\n %0A%09%09if(se\\n\",\n            \"created\": \"20201208032458753\",\n            \"creator\": \"Joshua Fontany\",\n            \"modified\": \"20201208032458793\",\n            \"modifier\": \"Joshua Fontany\",\n            \"modloader-source\": \"$:/core\",\n            \"modloader-target\": \"$:/core/modules/widgets/widget.js\",\n            \"type\": \"text/x-patch\"\n        }\n    }\n}","bag":"default","revision":"0","version":"0.1.2","type":"application/json","title":"$:/plugins/ebalster/attribute-modules","plugin-type":"plugin","modified":"20200101000000000","dependents":"","created":"20170101000000000","core-version":">=5.1.23"}]